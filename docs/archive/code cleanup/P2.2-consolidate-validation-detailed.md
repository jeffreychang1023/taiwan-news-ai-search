# P2.2: Consolidate Validation Logic - Detailed Implementation

**Estimated Effort**: 0.25 day
**Impact**: Medium - Eliminates duplicate validation code
**ROI**: ⭐⭐⭐⭐

---

## Problem Statement

In `analyst.py`, the methods `_validate_argument_graph()` and `_validate_knowledge_graph()` (lines 930-976) contain nearly identical validation logic for checking evidence IDs, duplicating ~30 lines of code.

---

## Solution

Create a generic `_validate_evidence_references()` helper method that can validate evidence IDs for any structure (claims, entities, relationships).

---

## Implementation

### BEFORE: Duplicate Validation Methods

```python
# In analyst.py (lines 930-976)

def _validate_argument_graph(
    self,
    arg_graph: ArgumentGraph,
    valid_citations: List[int],
) -> None:
    """Validate argument graph structure."""
    # Validate claims
    for claim in arg_graph.claims:
        invalid_ids = [eid for eid in claim.evidence_ids if eid not in valid_citations]
        if invalid_ids:
            self.logger.warning(
                f"Claim {claim.claim_id} has invalid evidence_ids: {invalid_ids}. "
                f"Valid range: 1-{max(valid_citations)}"
            )
            claim.evidence_ids = [eid for eid in claim.evidence_ids if eid in valid_citations]

    # Validate reasoning references
    claim_ids = {c.claim_id for c in arg_graph.claims}
    for reasoning in arg_graph.reasoning:
        if reasoning.from_claim_id not in claim_ids:
            self.logger.warning(
                f"Reasoning {reasoning.reasoning_id} references "
                f"non-existent from_claim_id: {reasoning.from_claim_id}"
            )
        if reasoning.to_claim_id not in claim_ids:
            self.logger.warning(
                f"Reasoning {reasoning.reasoning_id} references "
                f"non-existent to_claim_id: {reasoning.to_claim_id}"
            )


def _validate_knowledge_graph(
    self,
    kg: KnowledgeGraph,
    valid_citations: List[int],
) -> None:
    """Validate knowledge graph structure."""
    # Validate entities - DUPLICATE LOGIC
    for entity in kg.entities:
        invalid_ids = [eid for eid in entity.evidence_ids if eid not in valid_citations]
        if invalid_ids:
            self.logger.warning(
                f"Entity {entity.entity_id} ({entity.name}) has invalid evidence_ids: {invalid_ids}. "
                f"Valid range: 1-{max(valid_citations)}"
            )
            entity.evidence_ids = [eid for eid in entity.evidence_ids if eid in valid_citations]

    # Validate relationships - DUPLICATE LOGIC
    for rel in kg.relationships:
        invalid_ids = [eid for eid in rel.evidence_ids if eid not in valid_citations]
        if invalid_ids:
            self.logger.warning(
                f"Relationship {rel.relationship_id} has invalid evidence_ids: {invalid_ids}. "
                f"Valid range: 1-{max(valid_citations)}"
            )
            rel.evidence_ids = [eid for eid in rel.evidence_ids if eid in valid_citations]

    # Validate entity references
    entity_ids = {e.entity_id for e in kg.entities}
    for rel in kg.relationships:
        if rel.from_entity_id not in entity_ids:
            self.logger.warning(
                f"Relationship {rel.relationship_id} references "
                f"non-existent from_entity_id: {rel.from_entity_id}"
            )
        if rel.to_entity_id not in entity_ids:
            self.logger.warning(
                f"Relationship {rel.relationship_id} references "
                f"non-existent to_entity_id: {rel.to_entity_id}"
            )
```

### AFTER: Consolidated Validation

```python
# In analyst.py - Replace lines 930-976 with:

from typing import List, Any, Callable, Optional, Set


def _validate_evidence_references(
    self,
    items: List[Any],
    valid_citation_ids: Set[int],
    id_field: str = "evidence_ids",
    name_getter: Optional[Callable[[Any], str]] = None,
) -> None:
    """
    Generic validation for evidence ID references.

    Validates that all evidence_ids in items reference valid citations,
    logs warnings for invalid references, and removes them.

    Args:
        items: List of items to validate (claims, entities, relationships, etc.)
        valid_citation_ids: Set of valid citation IDs
        id_field: Name of the field containing evidence IDs (default: "evidence_ids")
        name_getter: Optional function to extract item name for logging.
                     If None, uses item's 'id' attribute or str(item).
    """
    if not name_getter:
        name_getter = lambda x: getattr(x, 'id', None) or getattr(x, 'claim_id', None) or str(x)

    max_valid_id = max(valid_citation_ids) if valid_citation_ids else 0

    for item in items:
        evidence_ids = getattr(item, id_field, [])
        if not evidence_ids:
            continue

        invalid_ids = [eid for eid in evidence_ids if eid not in valid_citation_ids]

        if invalid_ids:
            item_name = name_getter(item)
            self.logger.warning(
                f"{item_name} has invalid {id_field}: {invalid_ids}. "
                f"Valid range: 1-{max_valid_id}"
            )

            # Remove invalid IDs
            valid_ids = [eid for eid in evidence_ids if eid in valid_citation_ids]
            setattr(item, id_field, valid_ids)


def _validate_id_references(
    self,
    items: List[Any],
    valid_ids: Set[str],
    from_field: str,
    to_field: str,
    item_name_getter: Callable[[Any], str],
    reference_type: str,
) -> None:
    """
    Generic validation for ID cross-references.

    Validates that from/to ID fields reference valid IDs.

    Args:
        items: List of items with from/to references
        valid_ids: Set of valid IDs that can be referenced
        from_field: Field name for "from" reference
        to_field: Field name for "to" reference
        item_name_getter: Function to get item identifier for logging
        reference_type: Description of what's being referenced (for logging)
    """
    for item in items:
        item_name = item_name_getter(item)
        from_id = getattr(item, from_field, None)
        to_id = getattr(item, to_field, None)

        if from_id and from_id not in valid_ids:
            self.logger.warning(
                f"{item_name} references non-existent {from_field}: {from_id} "
                f"(valid {reference_type}: {valid_ids})"
            )

        if to_id and to_id not in valid_ids:
            self.logger.warning(
                f"{item_name} references non-existent {to_field}: {to_id} "
                f"(valid {reference_type}: {valid_ids})"
            )


def _validate_argument_graph(
    self,
    arg_graph: 'ArgumentGraph',
    valid_citations: List[int],
) -> None:
    """
    Validate argument graph structure and references.

    Args:
        arg_graph: ArgumentGraph to validate
        valid_citations: List of valid citation IDs
    """
    valid_citation_set = set(valid_citations)

    # Validate evidence IDs in claims
    self._validate_evidence_references(
        items=arg_graph.claims,
        valid_citation_ids=valid_citation_set,
        id_field="evidence_ids",
        name_getter=lambda c: f"Claim {c.claim_id}",
    )

    # Validate claim_id references in reasoning
    claim_ids = {c.claim_id for c in arg_graph.claims}
    self._validate_id_references(
        items=arg_graph.reasoning,
        valid_ids=claim_ids,
        from_field="from_claim_id",
        to_field="to_claim_id",
        item_name_getter=lambda r: f"Reasoning {r.reasoning_id}",
        reference_type="claim_ids",
    )


def _validate_knowledge_graph(
    self,
    kg: 'KnowledgeGraph',
    valid_citations: List[int],
) -> None:
    """
    Validate knowledge graph structure and references.

    Args:
        kg: KnowledgeGraph to validate
        valid_citations: List of valid citation IDs
    """
    valid_citation_set = set(valid_citations)

    # Validate evidence IDs in entities
    self._validate_evidence_references(
        items=kg.entities,
        valid_citation_ids=valid_citation_set,
        id_field="evidence_ids",
        name_getter=lambda e: f"Entity {e.entity_id} ({e.name})",
    )

    # Validate evidence IDs in relationships
    self._validate_evidence_references(
        items=kg.relationships,
        valid_citation_ids=valid_citation_set,
        id_field="evidence_ids",
        name_getter=lambda r: f"Relationship {r.relationship_id}",
    )

    # Validate entity_id references in relationships
    entity_ids = {e.entity_id for e in kg.entities}
    self._validate_id_references(
        items=kg.relationships,
        valid_ids=entity_ids,
        from_field="from_entity_id",
        to_field="to_entity_id",
        item_name_getter=lambda r: f"Relationship {r.relationship_id}",
        reference_type="entity_ids",
    )
```

---

## Complete Diff

```diff
--- a/code/python/reasoning/agents/analyst.py
+++ b/code/python/reasoning/agents/analyst.py
@@ -927,50 +927,80 @@ class AnalystAgent:

+    def _validate_evidence_references(
+        self,
+        items: List[Any],
+        valid_citation_ids: Set[int],
+        id_field: str = "evidence_ids",
+        name_getter: Optional[Callable[[Any], str]] = None,
+    ) -> None:
+        """Generic validation for evidence ID references."""
+        if not name_getter:
+            name_getter = lambda x: getattr(x, 'id', None) or str(x)
+
+        max_valid_id = max(valid_citation_ids) if valid_citation_ids else 0
+
+        for item in items:
+            evidence_ids = getattr(item, id_field, [])
+            if not evidence_ids:
+                continue
+
+            invalid_ids = [eid for eid in evidence_ids if eid not in valid_citation_ids]
+            if invalid_ids:
+                self.logger.warning(
+                    f"{name_getter(item)} has invalid {id_field}: {invalid_ids}. "
+                    f"Valid range: 1-{max_valid_id}"
+                )
+                setattr(item, id_field, [eid for eid in evidence_ids if eid in valid_citation_ids])
+
+    def _validate_id_references(
+        self,
+        items: List[Any],
+        valid_ids: Set[str],
+        from_field: str,
+        to_field: str,
+        item_name_getter: Callable[[Any], str],
+        reference_type: str,
+    ) -> None:
+        """Generic validation for ID cross-references."""
+        for item in items:
+            item_name = item_name_getter(item)
+            from_id = getattr(item, from_field, None)
+            to_id = getattr(item, to_field, None)
+
+            if from_id and from_id not in valid_ids:
+                self.logger.warning(f"{item_name} references non-existent {from_field}: {from_id}")
+            if to_id and to_id not in valid_ids:
+                self.logger.warning(f"{item_name} references non-existent {to_field}: {to_id}")

     def _validate_argument_graph(
         self,
         arg_graph: 'ArgumentGraph',
         valid_citations: List[int],
     ) -> None:
-        """Validate argument graph structure."""
-        # Validate claims
-        for claim in arg_graph.claims:
-            invalid_ids = [eid for eid in claim.evidence_ids if eid not in valid_citations]
-            if invalid_ids:
-                self.logger.warning(
-                    f"Claim {claim.claim_id} has invalid evidence_ids: {invalid_ids}. "
-                    f"Valid range: 1-{max(valid_citations)}"
-                )
-                claim.evidence_ids = [eid for eid in claim.evidence_ids if eid in valid_citations]
-
-        # Validate reasoning references
-        claim_ids = {c.claim_id for c in arg_graph.claims}
-        for reasoning in arg_graph.reasoning:
-            if reasoning.from_claim_id not in claim_ids:
-                self.logger.warning(...)
-            if reasoning.to_claim_id not in claim_ids:
-                self.logger.warning(...)
+        """Validate argument graph structure and references."""
+        valid_citation_set = set(valid_citations)
+
+        self._validate_evidence_references(
+            items=arg_graph.claims,
+            valid_citation_ids=valid_citation_set,
+            name_getter=lambda c: f"Claim {c.claim_id}",
+        )
+
+        claim_ids = {c.claim_id for c in arg_graph.claims}
+        self._validate_id_references(
+            items=arg_graph.reasoning,
+            valid_ids=claim_ids,
+            from_field="from_claim_id",
+            to_field="to_claim_id",
+            item_name_getter=lambda r: f"Reasoning {r.reasoning_id}",
+            reference_type="claim_ids",
+        )

     def _validate_knowledge_graph(
         self,
         kg: 'KnowledgeGraph',
         valid_citations: List[int],
     ) -> None:
-        """Validate knowledge graph structure."""
-        # DUPLICATE CODE REMOVED
-        ...
+        """Validate knowledge graph structure and references."""
+        valid_citation_set = set(valid_citations)
+
+        self._validate_evidence_references(
+            items=kg.entities,
+            valid_citation_ids=valid_citation_set,
+            name_getter=lambda e: f"Entity {e.entity_id} ({e.name})",
+        )
+
+        self._validate_evidence_references(
+            items=kg.relationships,
+            valid_citation_ids=valid_citation_set,
+            name_getter=lambda r: f"Relationship {r.relationship_id}",
+        )
+
+        entity_ids = {e.entity_id for e in kg.entities}
+        self._validate_id_references(
+            items=kg.relationships,
+            valid_ids=entity_ids,
+            from_field="from_entity_id",
+            to_field="to_entity_id",
+            item_name_getter=lambda r: f"Relationship {r.relationship_id}",
+            reference_type="entity_ids",
+        )
```

---

## Testing

```python
# tests/test_validation_consolidation.py

import pytest
from unittest.mock import MagicMock
from reasoning.agents.analyst import AnalystAgent


class MockClaim:
    def __init__(self, claim_id, evidence_ids):
        self.claim_id = claim_id
        self.evidence_ids = evidence_ids


class MockEntity:
    def __init__(self, entity_id, name, evidence_ids):
        self.entity_id = entity_id
        self.name = name
        self.evidence_ids = evidence_ids


class TestValidateEvidenceReferences:
    """Test generic evidence validation."""

    @pytest.fixture
    def analyst(self):
        agent = AnalystAgent(config={}, llm_client=None, logger=MagicMock())
        return agent

    def test_valid_references(self, analyst):
        """Test with all valid references."""
        claims = [
            MockClaim("C1", [1, 2]),
            MockClaim("C2", [2, 3]),
        ]

        analyst._validate_evidence_references(
            items=claims,
            valid_citation_ids={1, 2, 3, 4, 5},
            name_getter=lambda c: f"Claim {c.claim_id}",
        )

        # Should not modify valid IDs
        assert claims[0].evidence_ids == [1, 2]
        assert claims[1].evidence_ids == [2, 3]

    def test_invalid_references_removed(self, analyst):
        """Test that invalid references are removed."""
        claims = [
            MockClaim("C1", [1, 2, 99]),  # 99 is invalid
            MockClaim("C2", [100, 200]),   # all invalid
        ]

        analyst._validate_evidence_references(
            items=claims,
            valid_citation_ids={1, 2, 3},
            name_getter=lambda c: f"Claim {c.claim_id}",
        )

        # Invalid IDs should be removed
        assert claims[0].evidence_ids == [1, 2]
        assert claims[1].evidence_ids == []

        # Warning should be logged
        assert analyst.logger.warning.called

    def test_empty_evidence_ids(self, analyst):
        """Test handling of empty evidence_ids."""
        claims = [MockClaim("C1", [])]

        analyst._validate_evidence_references(
            items=claims,
            valid_citation_ids={1, 2, 3},
            name_getter=lambda c: f"Claim {c.claim_id}",
        )

        # Should not raise, no warnings
        assert not analyst.logger.warning.called


class TestValidateIdReferences:
    """Test ID cross-reference validation."""

    @pytest.fixture
    def analyst(self):
        agent = AnalystAgent(config={}, llm_client=None, logger=MagicMock())
        return agent

    def test_valid_id_references(self, analyst):
        """Test with valid ID references."""
        class MockReasoning:
            def __init__(self, rid, from_id, to_id):
                self.reasoning_id = rid
                self.from_claim_id = from_id
                self.to_claim_id = to_id

        items = [MockReasoning("R1", "C1", "C2")]

        analyst._validate_id_references(
            items=items,
            valid_ids={"C1", "C2", "C3"},
            from_field="from_claim_id",
            to_field="to_claim_id",
            item_name_getter=lambda r: f"Reasoning {r.reasoning_id}",
            reference_type="claim_ids",
        )

        assert not analyst.logger.warning.called

    def test_invalid_id_references(self, analyst):
        """Test with invalid ID references."""
        class MockReasoning:
            def __init__(self, rid, from_id, to_id):
                self.reasoning_id = rid
                self.from_claim_id = from_id
                self.to_claim_id = to_id

        items = [MockReasoning("R1", "C1", "C_INVALID")]

        analyst._validate_id_references(
            items=items,
            valid_ids={"C1", "C2"},
            from_field="from_claim_id",
            to_field="to_claim_id",
            item_name_getter=lambda r: f"Reasoning {r.reasoning_id}",
            reference_type="claim_ids",
        )

        # Should warn about invalid to_claim_id
        assert analyst.logger.warning.called
```

---

## Benefits

- ✅ Eliminates ~30 lines of duplicate code
- ✅ Single source of truth for validation logic
- ✅ Easy to add new validation targets (future graph types)
- ✅ Consistent warning messages
- ✅ Each validation helper independently testable
- ✅ Generic approach is reusable
