# P3.1: Extract Configuration from Code - Detailed Implementation

**Estimated Effort**: 0.5-1 day
**Impact**: Medium - Enables tuning without code changes
**ROI**: ⭐⭐⭐

---

## Problem Statement

Hardcoded values scattered throughout the codebase:
- Mode detection patterns in `deep_research.py`
- Critic compliance rules in `critic.py`
- Source tier thresholds in various files
- Magic numbers (max iterations, timeouts, etc.)

---

## Solution

1. Create YAML configuration files
2. Create centralized ConfigLoader
3. Update code to use configuration

---

## Implementation

### Step 1: Create Configuration Files

#### File: `config/mode_detection.yaml`

```yaml
# Mode detection patterns for research mode selection
mode_patterns:
  strict:
    keywords:
      - verify
      - is it true
      - fact check
      - check if
      - confirm
      - 真的嗎
      - 查證
      - 事實查核
      - 是否屬實
      - 驗證
    weight: 1.0
    description: "Fact-checking and verification queries"

  discovery:
    keywords:
      - explore
      - overview
      - understand
      - what is
      - explain
      - 是什麼
      - 探索
      - 了解
      - 介紹
      - 說明
    weight: 0.8
    description: "Exploratory research queries"

  monitor:
    keywords:
      - how has
      - evolution
      - trend
      - sentiment
      - tracking
      - change
      - progress
      - development
      - 演變
      - 趨勢
      - 變化
      - 追蹤
      - 發展
      - 走勢
    weight: 0.9
    description: "Monitoring and trend analysis queries"

# Default mode when no pattern matches
default_mode: discovery
```

#### File: `config/critic_rules.yaml`

```yaml
# Critic compliance rules by research mode
mode_compliance_rules:
  strict:
    reject_conditions:
      - "引用了 Tier 3-5 作為核心證據"
      - "缺少關鍵事實的直接引用"
      - "使用了過時資訊（超過時間範圍）"
      - "單一來源支持的重要聲明"
    warn_conditions:
      - "過度依賴單一來源"
      - "部分事實缺少多方驗證"
      - "有些引用來自較低可信度來源"
    min_tier_1_ratio: 0.6
    require_multi_source: true
    max_tier_for_core_claims: 2

  discovery:
    reject_conditions:
      - "視角過於單一，缺少多元觀點"
      - "未探索相關主題連結"
      - "分析深度不足"
    warn_conditions:
      - "某些面向探討不夠深入"
      - "缺少對立觀點的呈現"
    min_tier_1_ratio: 0.3
    require_multi_source: false
    max_tier_for_core_claims: 4

  monitor:
    reject_conditions:
      - "缺少時序分析"
      - "未標示重要轉折點"
      - "時間線有明顯跳躍"
    warn_conditions:
      - "某些時間段資料不足"
      - "趨勢分析缺乏數據支持"
    min_tier_1_ratio: 0.4
    require_multi_source: false
    max_tier_for_core_claims: 3
```

#### File: `config/source_filtering.yaml`

```yaml
# Source tier filtering configuration
source_tier_config:
  strict:
    tier_thresholds:
      min_tier: 1
      max_tier: 2
    min_tier_1_ratio: 0.6
    fallback_on_insufficient: true
    fallback_max_tier: 3

  discovery:
    tier_thresholds:
      min_tier: 1
      max_tier: 4
    min_tier_1_ratio: 0.3
    fallback_on_insufficient: false

  monitor:
    tier_thresholds:
      min_tier: 1
      max_tier: 3
    min_tier_1_ratio: 0.4
    fallback_on_insufficient: true
    fallback_max_tier: 4

# Source tier definitions
tier_definitions:
  1:
    name: "Official/Primary"
    description: "Official government, company statements, peer-reviewed"
    examples: ["政府公告", "公司財報", "學術論文"]
  2:
    name: "Major News"
    description: "Major news outlets with editorial standards"
    examples: ["Reuters", "聯合報", "中央社"]
  3:
    name: "Industry/Trade"
    description: "Industry publications and trade media"
    examples: ["TechCrunch", "科技新報"]
  4:
    name: "General Media"
    description: "General online media and blogs"
    examples: ["Medium", "個人部落格"]
  5:
    name: "Social/User"
    description: "Social media and user-generated content"
    examples: ["Twitter", "Reddit", "PTT"]
```

#### File: `config/reasoning_params.yaml`

```yaml
# Reasoning system parameters
reasoning:
  # Actor-Critic loop
  max_iterations: 3
  convergence_threshold: 0.9

  # Timeouts (in seconds)
  analyst_timeout: 120
  critic_timeout: 60
  writer_timeout: 90

  # Token limits
  max_context_tokens: 20000
  max_response_tokens: 4000
  max_snippet_length: 500

  # Feature flags
  enable_argument_graph: true
  enable_knowledge_graph: false
  enable_gap_enrichment: true
  enable_web_search: true

  # Gap enrichment
  gap_enrichment:
    max_gaps_to_search: 3
    max_queries_per_gap: 2
    min_importance: "high"  # critical, high, medium, low

  # Tracing
  tracing:
    console:
      enabled: true
      level: "INFO"  # DEBUG, INFO, WARNING, ERROR
    file:
      enabled: false
      path: "logs/reasoning/"

# Model selection
models:
  analyst: "gpt-4o"
  critic: "gpt-4o-mini"
  writer: "gpt-4o"
  clarification: "gpt-4o-mini"
```

---

### Step 2: Create Configuration Loader

#### File: `code/python/core/config_loader.py`

```python
"""Centralized configuration loader."""

import yaml
from pathlib import Path
from typing import Dict, Any, Optional, List
from functools import lru_cache
import logging
import os

logger = logging.getLogger(__name__)


class ConfigLoader:
    """
    Centralized configuration loader with caching.

    Loads YAML configuration files from the config directory
    and provides typed accessors for common configurations.
    """

    def __init__(self, config_dir: Optional[Path] = None):
        """
        Initialize ConfigLoader.

        Args:
            config_dir: Path to configuration directory.
                        Defaults to 'config/' relative to project root.
        """
        if config_dir is None:
            # Find config directory relative to this file
            code_dir = Path(__file__).parent.parent.parent.parent
            config_dir = code_dir / "config"

        self.config_dir = Path(config_dir)

        if not self.config_dir.exists():
            logger.warning(f"Config directory not found: {self.config_dir}")

    @lru_cache(maxsize=20)
    def load(self, config_name: str) -> Dict[str, Any]:
        """
        Load configuration file with caching.

        Args:
            config_name: Name of config file (without .yaml extension)

        Returns:
            Configuration dictionary

        Raises:
            FileNotFoundError: If config file doesn't exist
        """
        config_path = self.config_dir / f"{config_name}.yaml"

        if not config_path.exists():
            raise FileNotFoundError(f"Config not found: {config_path}")

        logger.debug(f"Loading config: {config_path}")

        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)

        return config or {}

    def reload(self, config_name: Optional[str] = None) -> None:
        """
        Clear cache and reload configuration(s).

        Args:
            config_name: Specific config to reload, or None for all
        """
        if config_name:
            # Clear specific cache entry
            self.load.cache_clear()
        else:
            self.load.cache_clear()

        logger.info(f"Config cache cleared: {config_name or 'all'}")

    # Typed accessors for common configurations

    def get_mode_patterns(self) -> Dict[str, Any]:
        """Get mode detection patterns."""
        config = self.load("mode_detection")
        return config.get("mode_patterns", {})

    def get_default_mode(self) -> str:
        """Get default research mode."""
        config = self.load("mode_detection")
        return config.get("default_mode", "discovery")

    def get_critic_rules(self, mode: str) -> Dict[str, Any]:
        """
        Get critic compliance rules for a mode.

        Args:
            mode: Research mode (strict, discovery, monitor)

        Returns:
            Rules dictionary for the mode
        """
        config = self.load("critic_rules")
        rules = config.get("mode_compliance_rules", {})
        return rules.get(mode, rules.get("discovery", {}))

    def get_source_tier_config(self, mode: str) -> Dict[str, Any]:
        """
        Get source tier filtering config for a mode.

        Args:
            mode: Research mode

        Returns:
            Tier configuration for the mode
        """
        config = self.load("source_filtering")
        tier_config = config.get("source_tier_config", {})
        return tier_config.get(mode, tier_config.get("discovery", {}))

    def get_tier_definitions(self) -> Dict[int, Dict[str, Any]]:
        """Get source tier definitions."""
        config = self.load("source_filtering")
        return config.get("tier_definitions", {})

    def get_reasoning_params(self) -> Dict[str, Any]:
        """Get reasoning system parameters."""
        config = self.load("reasoning_params")
        return config.get("reasoning", {})

    def get_model(self, agent: str) -> str:
        """
        Get model for an agent.

        Args:
            agent: Agent name (analyst, critic, writer, clarification)

        Returns:
            Model identifier string
        """
        config = self.load("reasoning_params")
        models = config.get("models", {})

        # Allow environment variable override
        env_key = f"NLWEB_{agent.upper()}_MODEL"
        return os.getenv(env_key) or models.get(agent, "gpt-4o-mini")

    def get(self, config_name: str, key: str, default: Any = None) -> Any:
        """
        Get a specific key from a config file.

        Args:
            config_name: Config file name
            key: Dot-separated key path (e.g., "reasoning.max_iterations")
            default: Default value if key not found

        Returns:
            Configuration value or default
        """
        try:
            config = self.load(config_name)
        except FileNotFoundError:
            return default

        # Navigate dot-separated path
        keys = key.split(".")
        value = config

        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
            else:
                return default

            if value is None:
                return default

        return value


# Global instance
config_loader = ConfigLoader()


# Convenience functions
def get_mode_patterns() -> Dict[str, Any]:
    """Get mode detection patterns."""
    return config_loader.get_mode_patterns()


def get_critic_rules(mode: str) -> Dict[str, Any]:
    """Get critic rules for mode."""
    return config_loader.get_critic_rules(mode)


def get_source_tier_config(mode: str) -> Dict[str, Any]:
    """Get source tier config for mode."""
    return config_loader.get_source_tier_config(mode)


def get_reasoning_param(key: str, default: Any = None) -> Any:
    """Get reasoning parameter."""
    return config_loader.get("reasoning_params", f"reasoning.{key}", default)
```

---

### Step 3: Update Code to Use Configuration

#### Update `deep_research.py`

```python
# BEFORE
MODE_DETECTION_PATTERNS = {
    'strict': {
        'keywords': ['verify', 'is it true', ...],
        'weight': 1.0,
    },
    # ... hardcoded
}

def _detect_research_mode(self) -> str:
    # ... uses hardcoded patterns


# AFTER
from core.config_loader import get_mode_patterns, config_loader

def _detect_research_mode(self) -> str:
    """Detect research mode using configurable patterns."""
    # Check explicit parameter first
    user_mode = self.query_params.get('research_mode')
    if user_mode in ['strict', 'discovery', 'monitor']:
        self.logger.info(f"Using explicit research_mode: {user_mode}")
        return user_mode

    # Load patterns from configuration
    mode_patterns = get_mode_patterns()

    query_lower = self.query.lower()
    mode_scores = {}

    for mode, config in mode_patterns.items():
        keywords = config.get('keywords', [])
        weight = config.get('weight', 1.0)

        matches = sum(1 for kw in keywords if kw in query_lower)
        if matches > 0:
            mode_scores[mode] = matches * weight

    if mode_scores:
        detected_mode = max(mode_scores, key=mode_scores.get)
        self.logger.info(
            f"Detected research_mode: {detected_mode} "
            f"(score: {mode_scores[detected_mode]:.2f})"
        )
        return detected_mode

    # Return configured default
    return config_loader.get_default_mode()
```

#### Update `critic.py`

```python
# BEFORE
def _build_mode_compliance_rules(self, mode: str) -> str:
    if mode == "strict":
        return """
        ## Strict 模式合規性檢查
        **直接拒絕條件**:
        - 引用了 Tier 3-5 作為核心證據
        ...
        """
    # ... hardcoded for each mode


# AFTER
from core.config_loader import get_critic_rules

def _build_mode_compliance_rules(self, mode: str) -> str:
    """Build mode compliance rules from configuration."""
    rules = get_critic_rules(mode)

    reject_conditions = rules.get("reject_conditions", [])
    warn_conditions = rules.get("warn_conditions", [])
    min_tier_1_ratio = rules.get("min_tier_1_ratio", 0.5)

    rules_text = f"## {mode.upper()} 模式合規性檢查\n\n"

    if reject_conditions:
        rules_text += "**直接拒絕條件**:\n"
        for condition in reject_conditions:
            rules_text += f"- {condition}\n"
        rules_text += "\n"

    if warn_conditions:
        rules_text += "**警告條件**:\n"
        for condition in warn_conditions:
            rules_text += f"- {condition}\n"
        rules_text += "\n"

    rules_text += f"**來源品質要求**: Tier 1 來源比例至少 {min_tier_1_ratio:.0%}\n"

    return rules_text
```

#### Update `orchestrator.py`

```python
# BEFORE
max_iterations = CONFIG.reasoning_params.get("max_iterations", 3)


# AFTER
from core.config_loader import get_reasoning_param

max_iterations = get_reasoning_param("max_iterations", 3)
analyst_timeout = get_reasoning_param("analyst_timeout", 120)
enable_kg = get_reasoning_param("enable_knowledge_graph", False)
```

---

## Testing

```python
# tests/test_config_loader.py

import pytest
from pathlib import Path
from core.config_loader import ConfigLoader, get_mode_patterns


class TestConfigLoader:
    """Test configuration loader."""

    @pytest.fixture
    def loader(self, tmp_path):
        """Create loader with temp config directory."""
        config_dir = tmp_path / "config"
        config_dir.mkdir()

        # Create test config
        mode_config = config_dir / "mode_detection.yaml"
        mode_config.write_text("""
mode_patterns:
  strict:
    keywords: ["verify", "check"]
    weight: 1.0
  discovery:
    keywords: ["explore"]
    weight: 0.8
default_mode: discovery
""")

        return ConfigLoader(config_dir)

    def test_load_config(self, loader):
        """Test loading configuration."""
        config = loader.load("mode_detection")

        assert "mode_patterns" in config
        assert "strict" in config["mode_patterns"]

    def test_caching(self, loader):
        """Test configuration caching."""
        config1 = loader.load("mode_detection")
        config2 = loader.load("mode_detection")

        assert config1 is config2  # Same object from cache

    def test_reload(self, loader):
        """Test cache clearing."""
        loader.load("mode_detection")
        loader.reload()

        # Cache should be empty
        assert loader.load.cache_info().hits == 0

    def test_get_mode_patterns(self, loader):
        """Test typed accessor."""
        patterns = loader.get_mode_patterns()

        assert "strict" in patterns
        assert patterns["strict"]["weight"] == 1.0

    def test_get_default_mode(self, loader):
        """Test default mode accessor."""
        default = loader.get_default_mode()
        assert default == "discovery"

    def test_missing_config(self, loader):
        """Test error on missing config."""
        with pytest.raises(FileNotFoundError):
            loader.load("nonexistent")

    def test_get_with_dot_path(self, loader):
        """Test dot-path key access."""
        value = loader.get("mode_detection", "mode_patterns.strict.weight")
        assert value == 1.0

    def test_get_with_default(self, loader):
        """Test default value for missing key."""
        value = loader.get("mode_detection", "nonexistent.key", "default")
        assert value == "default"
```

---

## Migration Checklist

- [ ] Create `config/mode_detection.yaml`
- [ ] Create `config/critic_rules.yaml`
- [ ] Create `config/source_filtering.yaml`
- [ ] Create `config/reasoning_params.yaml`
- [ ] Create `core/config_loader.py`
- [ ] Update `deep_research.py` to use config
- [ ] Update `critic.py` to use config
- [ ] Update `orchestrator.py` to use config
- [ ] Update other files with hardcoded values
- [ ] Write unit tests
- [ ] Update documentation

---

## Benefits

- ✅ No code changes needed to tune behavior
- ✅ Configuration changes are version controlled
- ✅ Easy A/B testing (swap config files)
- ✅ Environment-specific configs possible
- ✅ Clear documentation of system parameters
- ✅ Centralized configuration management
