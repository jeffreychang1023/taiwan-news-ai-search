# P1.3: Simplify Deep Research Ambiguity Detection - Detailed Implementation

**Estimated Effort**: 0.5-1 day
**Impact**: High - Simplifies 217-line method with embedded prompt
**ROI**: ⭐⭐⭐⭐

---

## Problem Statement

The `_detect_all_ambiguities()` method in `deep_research.py` (lines 399-615) is 217 lines long with a 145-line embedded prompt.

---

## Solution

1. Extract prompt to `reasoning/prompts/clarification.py`
2. Split method into focused helpers
3. Add pattern-based mode detection

---

## Implementation

### New File: `code/python/reasoning/prompts/clarification.py`

```python
"""Clarification and ambiguity detection prompt builder."""

from typing import Dict, Any, Optional
from .base import PromptBuilder


class ClarificationPromptBuilder(PromptBuilder):
    """Builder for ambiguity detection prompts."""

    def build_prompt(
        self,
        query: str,
        temporal_range: Optional[Dict[str, Any]] = None,
        has_time_ambiguity: bool = False,
    ) -> str:
        self.add_section(self._core_instructions(query, temporal_range, has_time_ambiguity))
        self.add_section(self._ambiguity_types())
        self.add_section(self._judgment_criteria())
        self.add_section(self._output_format())
        self.add_section(self._examples())
        return self.build()

    def _core_instructions(self, query: str, temporal_range: Optional[Dict], has_time_ambiguity: bool) -> str:
        time_status = "需要時間澄清" if has_time_ambiguity else "無時間歧義"
        return f"""你是一個新聞搜尋查詢歧義分析助手。請分析以下查詢是否存在歧義，並生成**多維度並行澄清問題**。

**語境**：這是一個新聞搜尋系統，用戶想找相關新聞報導。

使用者查詢：「{query}」

時間解析結果：{temporal_range}
規則檢測：{time_status}

**核心指令**：如果查詢同時存在「時間不明」和「範圍過廣」，請**務必同時返回**這兩個問題。"""

    def _ambiguity_types(self) -> str:
        return """請檢測以下三種歧義類型：

## 1. 時間歧義 (time)
- 查詢涉及時間敏感的人物、政策、事件，但未指定時間範圍
- 對於「最新」「股價」等即時性查詢，必須提供「今天」和「最近一周」選項
- 必須提供「全面回顧」選項

## 2. 範圍歧義 (scope)
- 查詢過於廣泛，涵蓋多個新聞主題面向
- 必須提供「全面了解」選項

## 3. 實體歧義 (entity)
- 查詢中的實體有多個不同的實體對象"""

    def _judgment_criteria(self) -> str:
        return """## 判斷標準
- Time & Scope 經常並存，請同時列出
- 明確的專有名詞不澄清
- 每個問題提供 2-4 個具體選項 + 1 個「全面」選項"""

    def _output_format(self) -> str:
        return """## 輸出格式

```json
{
  "questions": [
    {
      "clarification_type": "scope",
      "question": "AI發展涵蓋多個面向，你最想了解哪個部分？",
      "required": true,
      "options": [
        {"label": "技術突破", "intent": "technology", "query_modifier": "技術突破面向"},
        {"label": "全面了解", "intent": "comprehensive", "query_modifier": "", "is_comprehensive": true}
      ]
    }
  ]
}
```

如果沒有歧義，返回：`{"questions": []}`"""

    def _examples(self) -> str:
        return """## 範例

查詢：「蔡英文的兩岸政策」（Time + Scope 並存）
```json
{
  "questions": [
    {
      "clarification_type": "time",
      "question": "你想了解哪個時期的兩岸政策？",
      "required": true,
      "options": [
        {"label": "總統任期內", "intent": "presidency", "query_modifier": "總統任期"},
        {"label": "全面回顧", "intent": "comprehensive", "query_modifier": "", "is_comprehensive": true}
      ]
    },
    {
      "clarification_type": "scope",
      "question": "兩岸政策涵蓋多個面向，你最關注哪個？",
      "required": true,
      "options": [
        {"label": "外交立場", "intent": "diplomacy", "query_modifier": "外交立場"},
        {"label": "全面了解", "intent": "comprehensive", "query_modifier": "", "is_comprehensive": true}
      ]
    }
  ]
}
```"""


def build_clarification_prompt(**kwargs) -> str:
    builder = ClarificationPromptBuilder()
    return builder.build_prompt(**kwargs)
```

---

### Refactored Methods in `deep_research.py`

```python
# Add import
from reasoning.prompts.clarification import build_clarification_prompt

# Mode detection patterns
MODE_DETECTION_PATTERNS = {
    'strict': {
        'keywords': ['verify', 'fact check', '真的嗎', '查證', '是否屬實'],
        'weight': 1.0,
    },
    'discovery': {
        'keywords': ['explore', 'what is', '是什麼', '探索', '了解'],
        'weight': 0.8,
    },
    'monitor': {
        'keywords': ['trend', 'evolution', '趨勢', '演變', '走勢'],
        'weight': 0.9,
    },
}


async def _detect_all_ambiguities(self) -> list:
    """Detect all query ambiguities using LLM."""
    temporal_range = getattr(self, 'temporal_range', None)
    has_time_ambiguity = self._check_time_ambiguity_rules(temporal_range)

    prompt = build_clarification_prompt(
        query=self.query,
        temporal_range=temporal_range,
        has_time_ambiguity=has_time_ambiguity,
    )

    try:
        response = await self._call_ambiguity_detector(prompt)
        return self._parse_ambiguity_response(response)
    except Exception as e:
        self.logger.error(f"Ambiguity detection failed: {e}")
        return []


async def _call_ambiguity_detector(self, prompt: str) -> str:
    """Call LLM for ambiguity detection."""
    from core.llm import ask_llm
    return await ask_llm(
        prompt=prompt,
        model=self.CONFIG.get("clarification_model", "gpt-4o-mini"),
        temperature=0.1,
        max_tokens=1500,
    )


def _parse_ambiguity_response(self, response: str) -> list:
    """Parse and validate LLM response."""
    import json, re

    try:
        result = json.loads(response)
    except json.JSONDecodeError:
        match = re.search(r'\{.*\}', response, re.DOTALL)
        if match:
            result = json.loads(match.group(0))
        else:
            raise ValueError("Could not extract JSON")

    questions = result.get("questions", [])
    return [q for q in questions if self._validate_question(q)]


def _validate_question(self, question: dict) -> bool:
    """Validate question structure."""
    if not all(k in question for k in ["clarification_type", "question", "options"]):
        return False
    if question["clarification_type"] not in ["time", "scope", "entity"]:
        return False
    opts = question.get("options", [])
    return len(opts) >= 2 and all("label" in o and "intent" in o for o in opts)


def _check_time_ambiguity_rules(self, temporal_range: Optional[Dict]) -> bool:
    """Rule-based time ambiguity check."""
    if not temporal_range or not temporal_range.get("is_temporal"):
        keywords = ["最新", "現在", "今天", "latest", "current"]
        return any(kw in self.query.lower() for kw in keywords)
    return temporal_range.get("method") in ["implicit", "relative_ambiguous"]


def _detect_research_mode(self) -> str:
    """Detect research mode from query."""
    user_mode = self.query_params.get('research_mode')
    if user_mode in ['strict', 'discovery', 'monitor']:
        return user_mode

    query_lower = self.query.lower()
    scores = {}
    for mode, cfg in MODE_DETECTION_PATTERNS.items():
        matches = sum(1 for kw in cfg['keywords'] if kw in query_lower)
        if matches:
            scores[mode] = matches * cfg['weight']

    return max(scores, key=scores.get) if scores else 'discovery'
```

---

## Benefits

- ✅ 217 lines → ~60 lines
- ✅ Prompt extracted and maintainable
- ✅ Each helper independently testable
- ✅ Mode detection configurable
