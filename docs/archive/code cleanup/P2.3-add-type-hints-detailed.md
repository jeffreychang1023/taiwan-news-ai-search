# P2.3: Add Comprehensive Type Hints - Detailed Implementation

**Estimated Effort**: 1-2 days
**Impact**: High - Improves IDE support, catches bugs early
**ROI**: ⭐⭐⭐

---

## Problem Statement

The codebase has inconsistent type hint coverage:
- Some methods have full type hints
- Many methods have partial or no type hints
- Return types often missing
- Complex types not annotated

This makes IDE support weak and allows type-related bugs to slip through.

---

## Solution

1. Add comprehensive type hints to all public methods
2. Create protocol types for common interfaces
3. Configure mypy for type checking
4. Run mypy in CI pipeline

---

## Implementation

### Step 1: Create mypy Configuration

#### File: `mypy.ini`

```ini
[mypy]
python_version = 3.11
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
show_error_codes = True
pretty = True

# Strict mode for new code
strict = False

# Ignore missing imports for third-party libraries
[mypy-qdrant_client.*]
ignore_missing_imports = True

[mypy-openai.*]
ignore_missing_imports = True

[mypy-anthropic.*]
ignore_missing_imports = True

[mypy-aiohttp.*]
ignore_missing_imports = True

[mypy-azure.*]
ignore_missing_imports = True

[mypy-xgboost.*]
ignore_missing_imports = True

[mypy-numpy.*]
ignore_missing_imports = True

[mypy-sklearn.*]
ignore_missing_imports = True
```

---

### Step 2: Create Protocol Types

#### File: `code/python/core/protocols.py`

```python
"""Protocol types for common interfaces."""

from typing import Protocol, Dict, Any, List, Optional, Callable, runtime_checkable


@runtime_checkable
class LLMClient(Protocol):
    """Protocol for LLM client interface."""

    async def chat_completion(
        self,
        messages: List[Dict[str, str]],
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 1000,
    ) -> Dict[str, Any]:
        """Execute chat completion."""
        ...

    async def completion(
        self,
        prompt: str,
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 1000,
    ) -> str:
        """Execute text completion."""
        ...


@runtime_checkable
class HttpHandler(Protocol):
    """Protocol for HTTP handler interface."""

    async def send_response(
        self,
        data: Dict[str, Any],
        status: int = 200,
    ) -> None:
        """Send HTTP response."""
        ...

    async def send_sse(
        self,
        event: str,
        data: Dict[str, Any],
    ) -> None:
        """Send Server-Sent Event."""
        ...


@runtime_checkable
class VectorStore(Protocol):
    """Protocol for vector store interface."""

    async def search(
        self,
        query: str,
        top_k: int = 10,
        filters: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """Search for similar documents."""
        ...

    async def upsert(
        self,
        documents: List[Dict[str, Any]],
        embeddings: List[List[float]],
    ) -> None:
        """Upsert documents with embeddings."""
        ...


@runtime_checkable
class ProgressCallback(Protocol):
    """Protocol for progress update callbacks."""

    def __call__(
        self,
        event_type: str,
        data: Dict[str, Any],
    ) -> None:
        """Send progress event."""
        ...


# Type aliases for common structures
QueryParams = Dict[str, Any]
SearchResult = Dict[str, Any]
SearchResults = List[SearchResult]


class TemporalContext:
    """Typed temporal context structure."""

    def __init__(
        self,
        is_temporal: bool = False,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        method: str = "none",
    ):
        self.is_temporal = is_temporal
        self.start_date = start_date
        self.end_date = end_date
        self.method = method

    def to_dict(self) -> Dict[str, Any]:
        return {
            "is_temporal": self.is_temporal,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "method": self.method,
        }
```

---

### Step 3: Add Type Hints to Key Files

#### File: `code/python/reasoning/orchestrator.py`

```python
"""Research orchestrator with full type hints."""

from typing import (
    List, Dict, Any, Optional, Tuple, Callable, Union, TYPE_CHECKING
)
import logging
import json
from datetime import datetime

if TYPE_CHECKING:
    from reasoning.utils.console_tracer import ConsoleTracer
    from reasoning.utils.iteration_logger import IterationLogger
    from reasoning.agents.analyst import AnalystAgent
    from reasoning.agents.critic import CriticAgent
    from reasoning.agents.writer import WriterAgent
    from core.protocols import ProgressCallback


class ResearchOrchestrator:
    """
    Multi-agent reasoning orchestrator with Actor-Critic pattern.

    Coordinates Analyst, Critic, and Writer agents for deep research.
    """

    def __init__(
        self,
        handler: Any,  # BaseHandler instance
        config: Optional[Dict[str, Any]] = None,
    ) -> None:
        """
        Initialize orchestrator.

        Args:
            handler: Base handler instance with query context
            config: Optional configuration override
        """
        self.handler = handler
        self.config = config or {}
        self.logger: logging.Logger = logging.getLogger(__name__)

        # Initialize agents (lazy or eager based on config)
        self._analyst: Optional['AnalystAgent'] = None
        self._critic: Optional['CriticAgent'] = None
        self._writer: Optional['WriterAgent'] = None

        # Callback for progress updates
        self._progress_callback: Optional['ProgressCallback'] = None

    @property
    def analyst(self) -> 'AnalystAgent':
        """Lazy initialization of analyst agent."""
        if self._analyst is None:
            from reasoning.agents.analyst import AnalystAgent
            self._analyst = AnalystAgent(self.config, self.logger)
        return self._analyst

    @property
    def critic(self) -> 'CriticAgent':
        """Lazy initialization of critic agent."""
        if self._critic is None:
            from reasoning.agents.critic import CriticAgent
            self._critic = CriticAgent(self.config, self.logger)
        return self._critic

    @property
    def writer(self) -> 'WriterAgent':
        """Lazy initialization of writer agent."""
        if self._writer is None:
            from reasoning.agents.writer import WriterAgent
            self._writer = WriterAgent(self.config, self.logger)
        return self._writer

    async def run_research(
        self,
        query: str,
        mode: str,
        items: List[Dict[str, Any]],
        temporal_context: Optional[Dict[str, Any]] = None,
        enable_kg: bool = False,
        enable_web_search: bool = False,
    ) -> List[Dict[str, Any]]:
        """
        Execute deep research using Actor-Critic loop.

        Args:
            query: User's research question
            mode: Research mode ('strict', 'discovery', 'monitor')
            items: Retrieved source items
            temporal_context: Optional temporal constraints
            enable_kg: Enable knowledge graph generation
            enable_web_search: Enable web search for gaps

        Returns:
            List of result items with research report
        """
        ...

    def _setup_research_session(
        self,
        query_id: str,
        query: str,
        mode: str,
    ) -> Tuple['IterationLogger', Optional['ConsoleTracer']]:
        """Initialize logging and tracing."""
        ...

    async def _filter_and_prepare_sources(
        self,
        items: List[Dict[str, Any]],
        mode: str,
        tracer: Optional['ConsoleTracer'],
    ) -> List[Dict[str, Any]]:
        """Apply source tier filtering."""
        ...

    async def _run_actor_critic_loop(
        self,
        query: str,
        mode: str,
        formatted_context: str,
        source_map: Dict[int, Dict[str, Any]],
        temporal_context: Optional[Dict[str, Any]],
        enable_web_search: bool,
        iteration_logger: 'IterationLogger',
        tracer: Optional['ConsoleTracer'],
    ) -> Tuple[Optional[str], Optional[str], List[Dict[str, Any]]]:
        """Run iterative Actor-Critic loop."""
        ...

    async def _run_analyst_phase(
        self,
        query: str,
        mode: str,
        formatted_context: str,
        temporal_context: Optional[Dict[str, Any]],
        enable_web_search: bool,
        iteration: int,
        previous_review: Optional[str],
        tracer: Optional['ConsoleTracer'],
    ) -> str:
        """Execute analyst research phase."""
        ...

    async def _run_critic_phase(
        self,
        draft: str,
        query: str,
        mode: str,
        formatted_context: str,
        temporal_context: Optional[Dict[str, Any]],
        iteration: int,
        tracer: Optional['ConsoleTracer'],
    ) -> str:
        """Execute critic review phase."""
        ...

    def _should_stop_iteration(
        self,
        review: str,
        iteration: int,
        max_iterations: int,
    ) -> bool:
        """Check if Actor-Critic loop should stop."""
        ...

    async def _handle_gap_enrichment(
        self,
        draft: str,
        mode: str,
        enable_web_search: bool,
        tracer: Optional['ConsoleTracer'],
    ) -> List[Dict[str, Any]]:
        """Detect and enrich information gaps."""
        ...

    async def _generate_final_report(
        self,
        draft: str,
        review: Optional[str],
        query: str,
        mode: str,
        all_sources: List[Dict[str, Any]],
        tracer: Optional['ConsoleTracer'],
    ) -> str:
        """Generate final report using Writer."""
        ...

    def _create_error_response(
        self,
        error_msg: str,
        query: str,
        details: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """Create standardized error response."""
        ...

    def _format_context_shared(
        self,
        items: List[Dict[str, Any]],
    ) -> Tuple[str, Dict[int, Dict[str, Any]]]:
        """Format items into citation context."""
        ...
```

---

#### File: `code/python/core/baseHandler.py`

```python
"""Base handler with full type hints."""

from typing import (
    Dict, Any, List, Optional, Union, TYPE_CHECKING
)
import asyncio
import time
import logging

if TYPE_CHECKING:
    from core.protocols import HttpHandler
    from core.analytics_db import AnalyticsDB


class BaseHandler:
    """Base handler for NLWeb search queries."""

    # Class-level type hints for instance attributes
    http_handler: 'HttpHandler'
    query_params: Dict[str, Any]
    query: str
    site: Union[str, List[str]]
    model: str
    streaming: bool
    debug_mode: bool
    query_done: bool
    retrieved_items: List[Dict[str, Any]]
    final_ranked_answers: List[Dict[str, Any]]
    metrics: Dict[str, float]

    def __init__(
        self,
        query_params: Dict[str, Any],
        http_handler: 'HttpHandler',
    ) -> None:
        """
        Initialize BaseHandler.

        Args:
            query_params: Query parameters from request
            http_handler: HTTP handler for responses
        """
        self.http_handler = http_handler
        self.query_params = query_params

        self._init_core_params()
        self._init_query_context()
        self._init_conversation()
        self._init_state()
        self._init_synchronization()
        self._init_analytics()

    def _init_core_params(self) -> None:
        """Initialize core query parameters."""
        ...

    def _init_query_context(self) -> None:
        """Initialize query-specific context."""
        ...

    def _init_conversation(self) -> None:
        """Initialize conversation tracking."""
        ...

    def _init_state(self) -> None:
        """Initialize state variables."""
        ...

    def _init_synchronization(self) -> None:
        """Initialize async synchronization primitives."""
        ...

    def _init_analytics(self) -> None:
        """Initialize analytics tracking."""
        ...

    @property
    def analytics_db(self) -> 'AnalyticsDB':
        """Lazy initialization of analytics database."""
        ...

    async def process_query(self) -> Dict[str, Any]:
        """
        Process the search query.

        Returns:
            Result dictionary with search results
        """
        ...

    async def send_result(
        self,
        result: Dict[str, Any],
        is_final: bool = False,
    ) -> None:
        """
        Send result to client.

        Args:
            result: Result data to send
            is_final: Whether this is the final result
        """
        ...

    def get_elapsed_time(self) -> float:
        """Get elapsed time since initialization."""
        return time.time() - self.init_time
```

---

#### File: `code/python/reasoning/agents/analyst.py`

```python
"""Analyst agent with full type hints."""

from typing import (
    Dict, Any, List, Optional, Tuple, TYPE_CHECKING
)
import logging
import json

if TYPE_CHECKING:
    from reasoning.schemas_enhanced import (
        ArgumentGraph, KnowledgeGraph, Claim, Reasoning,
        Entity, Relationship
    )


class AnalystAgent:
    """Research analyst agent for deep analysis."""

    def __init__(
        self,
        config: Dict[str, Any],
        logger: logging.Logger,
    ) -> None:
        """
        Initialize analyst agent.

        Args:
            config: Configuration dictionary
            logger: Logger instance
        """
        self.config = config
        self.logger = logger

    async def analyze(
        self,
        query: str,
        mode: str,
        items: List[Dict[str, Any]],
        temporal_context: Optional[Dict[str, Any]] = None,
        iteration: int = 0,
        previous_review: Optional[str] = None,
    ) -> str:
        """
        Perform research analysis.

        Args:
            query: Research question
            mode: Research mode
            items: Source items
            temporal_context: Temporal constraints
            iteration: Current iteration number
            previous_review: Previous critic feedback

        Returns:
            Analysis result as JSON string
        """
        ...

    def _build_research_prompt(
        self,
        query: str,
        formatted_context: str,
        mode: str,
        temporal_context: Optional[Dict[str, Any]] = None,
        enable_argument_graph: bool = False,
        enable_knowledge_graph: bool = False,
        enable_gap_enrichment: bool = False,
        enable_web_search: bool = False,
    ) -> str:
        """Build research prompt using template builder."""
        ...

    async def generate(self, prompt: str) -> str:
        """
        Generate response from LLM.

        Args:
            prompt: Complete prompt to send

        Returns:
            LLM response string
        """
        ...

    def _parse_response(
        self,
        response: str,
    ) -> Dict[str, Any]:
        """
        Parse LLM response into structured data.

        Args:
            response: Raw LLM response

        Returns:
            Parsed response dictionary

        Raises:
            ValueError: If response cannot be parsed
        """
        ...

    def _validate_evidence_references(
        self,
        items: List[Any],
        valid_citation_ids: set,
        id_field: str = "evidence_ids",
        name_getter: Optional[callable] = None,
    ) -> None:
        """Validate evidence ID references."""
        ...

    def _validate_argument_graph(
        self,
        arg_graph: 'ArgumentGraph',
        valid_citations: List[int],
    ) -> None:
        """Validate argument graph structure."""
        ...

    def _validate_knowledge_graph(
        self,
        kg: 'KnowledgeGraph',
        valid_citations: List[int],
    ) -> None:
        """Validate knowledge graph structure."""
        ...
```

---

### Step 4: Common Type Aliases

#### File: `code/python/core/types.py`

```python
"""Common type aliases for the codebase."""

from typing import (
    Dict, Any, List, Optional, Union, Callable, Awaitable, TypeVar
)

# Generic type variable
T = TypeVar('T')

# Query and search types
QueryParams = Dict[str, Any]
SearchResult = Dict[str, Any]
SearchResults = List[SearchResult]

# Item types
ItemDict = Dict[str, Any]
ItemList = List[ItemDict]

# Callback types
SyncCallback = Callable[..., None]
AsyncCallback = Callable[..., Awaitable[None]]
ProgressCallback = Callable[[str, Dict[str, Any]], None]

# Configuration types
ConfigDict = Dict[str, Any]

# Response types
ResponseDict = Dict[str, Any]
ErrorDict = Dict[str, Union[str, int, Dict[str, Any]]]

# Temporal types
TemporalDict = Dict[str, Any]

# Graph types
ClaimDict = Dict[str, Any]
EntityDict = Dict[str, Any]
RelationshipDict = Dict[str, Any]
ArgumentGraphDict = Dict[str, List[ClaimDict]]
KnowledgeGraphDict = Dict[str, List[Union[EntityDict, RelationshipDict]]]

# Citation types
CitationId = int
CitationIds = List[CitationId]
CitationMap = Dict[CitationId, ItemDict]
```

---

## Running Type Checks

### Command Line

```bash
# Install mypy
pip install mypy types-PyYAML types-aiohttp

# Run on specific file
mypy code/python/reasoning/orchestrator.py

# Run on entire module
mypy code/python/reasoning/

# Run with strict mode
mypy code/python/reasoning/ --strict

# Generate HTML report
mypy code/python/reasoning/ --html-report mypy-report
```

### Pre-commit Hook

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies:
          - types-PyYAML
          - types-aiohttp
```

### CI Integration

```yaml
# .github/workflows/type-check.yml
name: Type Check

on: [push, pull_request]

jobs:
  mypy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - run: pip install mypy types-PyYAML types-aiohttp
      - run: mypy code/python/reasoning/ code/python/core/
```

---

## Testing Type Hints

```python
# tests/test_type_hints.py

import subprocess
import sys


def test_mypy_orchestrator():
    """Verify orchestrator passes type checking."""
    result = subprocess.run(
        [sys.executable, "-m", "mypy", "code/python/reasoning/orchestrator.py"],
        capture_output=True,
        text=True,
    )
    assert result.returncode == 0, f"mypy errors:\n{result.stdout}\n{result.stderr}"


def test_mypy_base_handler():
    """Verify base handler passes type checking."""
    result = subprocess.run(
        [sys.executable, "-m", "mypy", "code/python/core/baseHandler.py"],
        capture_output=True,
        text=True,
    )
    assert result.returncode == 0, f"mypy errors:\n{result.stdout}\n{result.stderr}"
```

---

## Implementation Checklist

- [ ] Create `mypy.ini` configuration
- [ ] Create `core/protocols.py` with interface types
- [ ] Create `core/types.py` with type aliases
- [ ] Add type hints to `orchestrator.py`
- [ ] Add type hints to `baseHandler.py`
- [ ] Add type hints to `analyst.py`
- [ ] Add type hints to `critic.py`
- [ ] Add type hints to `writer.py`
- [ ] Add type hints to `deep_research.py`
- [ ] Run mypy and fix all errors
- [ ] Add pre-commit hook
- [ ] Add CI workflow

---

## Benefits

- ✅ IDE autocomplete and refactoring support
- ✅ Catch type errors before runtime
- ✅ Self-documenting code
- ✅ Better API understanding
- ✅ Easier onboarding for new developers
- ✅ Protocol types for dependency injection
