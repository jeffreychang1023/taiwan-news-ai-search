# P3.3: Reduce Deep Nesting - Detailed Implementation

**Estimated Effort**: 1 day
**Impact**: Medium - Improves code readability
**ROI**: ⭐⭐

---

## Problem Statement

Several methods have 4+ levels of nesting, making control flow hard to follow:
- Nested if/else blocks
- Nested try/except
- Nested loops with conditionals

---

## Solution

Apply two key techniques:
1. **Early Returns** - Exit early on failure conditions
2. **Extract Methods** - Move nested blocks to helper methods

---

## Implementation

### Example 1: Gap Processing (orchestrator.py)

#### BEFORE: Deep Nesting

```python
async def process_gaps(self, draft: str) -> List[Dict]:
    try:
        draft_data = json.loads(draft)
        gaps = draft_data.get("information_gaps", [])

        if gaps:
            search_gaps = [g for g in gaps if g.get("importance") == "critical"]

            if search_gaps:
                results = []
                for gap in search_gaps:
                    if gap.get("suggested_queries"):
                        for query in gap["suggested_queries"]:
                            try:
                                result = await self.search(query)
                                if result:
                                    results.append(result)
                            except Exception as e:
                                self.logger.error(f"Search failed: {e}")
                return results
    except Exception as e:
        self.logger.error(f"Gap processing failed: {e}")

    return []
```

**Problems**:
- 6 levels of nesting
- Multiple responsibilities mixed
- Hard to test individual parts
- Error handling scattered

#### AFTER: Early Returns + Extracted Methods

```python
async def process_gaps(self, draft: str) -> List[Dict]:
    """
    Process information gaps with flat control flow.

    Uses early returns to minimize nesting.
    """
    # Parse draft
    gaps = self._extract_gaps_from_draft(draft)
    if not gaps:
        return []

    # Filter critical gaps
    critical_gaps = self._filter_critical_gaps(gaps)
    if not critical_gaps:
        return []

    # Process each gap
    results = []
    for gap in critical_gaps:
        gap_results = await self._process_single_gap(gap)
        results.extend(gap_results)

    return results


def _extract_gaps_from_draft(self, draft: str) -> List[Dict]:
    """Extract gaps list from draft JSON."""
    try:
        draft_data = json.loads(draft)
        return draft_data.get("information_gaps", [])
    except json.JSONDecodeError as e:
        self.logger.warning(f"Failed to parse draft: {e}")
        return []


def _filter_critical_gaps(self, gaps: List[Dict]) -> List[Dict]:
    """Filter for high-priority gaps requiring search."""
    return [
        g for g in gaps
        if g.get("importance") in ["critical", "high"]
        and g.get("suggested_queries")
    ]


async def _process_single_gap(self, gap: Dict) -> List[Dict]:
    """Process a single information gap."""
    queries = gap.get("suggested_queries", [])
    results = []

    for query in queries[:2]:  # Limit queries per gap
        result = await self._safe_search(query)
        if result:
            results.append(result)

    return results


async def _safe_search(self, query: str) -> Optional[Dict]:
    """Execute search with error handling."""
    try:
        return await self.search(query)
    except Exception as e:
        self.logger.error(f"Search failed for '{query}': {e}")
        return None
```

---

### Example 2: Iteration Handling (orchestrator.py)

#### BEFORE: Deep Nesting

```python
async def handle_iteration(self, iteration: int):
    if iteration < self.max_iterations:
        draft = await self.analyst.analyze(...)

        if draft:
            if self.enable_gap_detection:
                gaps = await self.detect_gaps(draft)

                if gaps:
                    for gap in gaps:
                        if gap.get("requires_search"):
                            queries = gap.get("queries", [])
                            if queries:
                                for query in queries:
                                    results = await self.search(query)
                                    if results:
                                        self.add_sources(results)
```

#### AFTER: Early Returns + Extraction

```python
async def handle_iteration(self, iteration: int) -> Optional[str]:
    """
    Handle single iteration of Actor-Critic loop.

    Returns:
        Draft from analyst, or None if iteration should stop
    """
    # Guard: Check iteration limit
    if iteration >= self.max_iterations:
        return None

    # Run analyst
    draft = await self.analyst.analyze(...)
    if not draft:
        self.logger.warning("Analyst produced no draft")
        return None

    # Handle gap detection (optional)
    await self._maybe_enrich_with_gaps(draft)

    return draft


async def _maybe_enrich_with_gaps(self, draft: str) -> None:
    """Optionally enrich context with gap searches."""
    if not self.enable_gap_detection:
        return

    gaps = await self.detect_gaps(draft)
    if not gaps:
        return

    await self._process_gap_searches(gaps)


async def _process_gap_searches(self, gaps: List[Dict]) -> None:
    """Process search queries for all gaps."""
    for gap in gaps:
        if not gap.get("requires_search"):
            continue

        queries = gap.get("queries", [])
        await self._execute_gap_queries(queries)


async def _execute_gap_queries(self, queries: List[str]) -> None:
    """Execute queries and add results to sources."""
    for query in queries:
        results = await self.search(query)
        if results:
            self.add_sources(results)
```

---

### Example 3: Response Parsing (analyst.py)

#### BEFORE: Nested Try/Except

```python
def parse_response(self, response: str) -> Dict:
    try:
        result = json.loads(response)
        if isinstance(result, dict):
            if "analysis" in result:
                if result.get("citations_used"):
                    valid_citations = []
                    for cid in result["citations_used"]:
                        if isinstance(cid, int):
                            if 1 <= cid <= self.max_citations:
                                valid_citations.append(cid)
                    result["citations_used"] = valid_citations
                return result
            else:
                raise ValueError("Missing analysis field")
        else:
            raise ValueError("Expected dict response")
    except json.JSONDecodeError:
        # Try to extract JSON from markdown
        try:
            match = re.search(r'```json\s*(.*?)\s*```', response, re.DOTALL)
            if match:
                return json.loads(match.group(1))
        except:
            pass
        raise ValueError("Could not parse response")
```

#### AFTER: Flat with Early Validation

```python
def parse_response(self, response: str) -> Dict:
    """
    Parse analyst response with flat control flow.

    Uses early validation and guard clauses.
    """
    # Try direct parse first
    result = self._try_parse_json(response)

    # Validate structure
    self._validate_response_structure(result)

    # Clean citations
    result["citations_used"] = self._validate_citations(
        result.get("citations_used", [])
    )

    return result


def _try_parse_json(self, response: str) -> Dict:
    """Try to parse JSON from response."""
    # Direct parse
    try:
        return json.loads(response)
    except json.JSONDecodeError:
        pass

    # Try markdown extraction
    match = re.search(r'```json\s*(.*?)\s*```', response, re.DOTALL)
    if match:
        try:
            return json.loads(match.group(1))
        except json.JSONDecodeError:
            pass

    # Try finding raw JSON object
    match = re.search(r'\{.*\}', response, re.DOTALL)
    if match:
        try:
            return json.loads(match.group(0))
        except json.JSONDecodeError:
            pass

    raise ValueError(f"Could not parse JSON from response: {response[:200]}")


def _validate_response_structure(self, result: Any) -> None:
    """Validate response is a dict with required fields."""
    if not isinstance(result, dict):
        raise ValueError(f"Expected dict, got {type(result).__name__}")

    if "analysis" not in result:
        raise ValueError("Missing required 'analysis' field")


def _validate_citations(self, citations: List) -> List[int]:
    """Validate and filter citation IDs."""
    if not citations:
        return []

    valid = []
    for cid in citations:
        if not isinstance(cid, int):
            continue
        if 1 <= cid <= self.max_citations:
            valid.append(cid)

    return valid
```

---

### Example 4: Source Filtering (source_filter.py)

#### BEFORE

```python
def filter_sources(self, items, mode):
    results = []
    for item in items:
        if item:
            tier = item.get("tier")
            if tier:
                if isinstance(tier, int):
                    if mode == "strict":
                        if tier <= 2:
                            if item.get("url"):
                                results.append(item)
                    elif mode == "discovery":
                        if tier <= 4:
                            results.append(item)
                    else:
                        if tier <= 3:
                            results.append(item)
    return results
```

#### AFTER

```python
def filter_sources(self, items: List[Dict], mode: str) -> List[Dict]:
    """
    Filter sources by tier for research mode.

    Uses list comprehension with extracted predicate.
    """
    max_tier = self._get_max_tier_for_mode(mode)
    return [
        item for item in items
        if self._is_valid_source(item, max_tier)
    ]


def _get_max_tier_for_mode(self, mode: str) -> int:
    """Get maximum allowed tier for mode."""
    tier_limits = {
        "strict": 2,
        "discovery": 4,
        "monitor": 3,
    }
    return tier_limits.get(mode, 3)


def _is_valid_source(self, item: Dict, max_tier: int) -> bool:
    """Check if source meets tier requirement."""
    if not item:
        return False

    tier = item.get("tier")
    if not isinstance(tier, int):
        return False

    return tier <= max_tier
```

---

## Refactoring Patterns Summary

### Pattern 1: Guard Clauses (Early Return)

```python
# BEFORE
def process(self, data):
    if data:
        if data.get("valid"):
            if len(data["items"]) > 0:
                # actual logic here
                return result
    return None

# AFTER
def process(self, data):
    if not data:
        return None
    if not data.get("valid"):
        return None
    if not data.get("items"):
        return None

    # actual logic here (no nesting!)
    return result
```

### Pattern 2: Extract Conditional Logic

```python
# BEFORE
if item.get("type") == "A" and item.get("status") == "active" and item.get("score", 0) > 0.5:
    process(item)

# AFTER
def _should_process(self, item: Dict) -> bool:
    return (
        item.get("type") == "A"
        and item.get("status") == "active"
        and item.get("score", 0) > 0.5
    )

if self._should_process(item):
    process(item)
```

### Pattern 3: Replace Nested Loops with Methods

```python
# BEFORE
for group in groups:
    for item in group.items:
        for property in item.properties:
            if property.name == "target":
                process(property)

# AFTER
def _find_target_properties(self, groups):
    for group in groups:
        yield from self._extract_properties(group)

def _extract_properties(self, group):
    for item in group.items:
        for prop in item.properties:
            if prop.name == "target":
                yield prop

for prop in self._find_target_properties(groups):
    process(prop)
```

### Pattern 4: Use Dictionary for Switch-like Logic

```python
# BEFORE
if mode == "strict":
    threshold = 0.9
elif mode == "discovery":
    threshold = 0.7
elif mode == "monitor":
    threshold = 0.8
else:
    threshold = 0.75

# AFTER
THRESHOLDS = {
    "strict": 0.9,
    "discovery": 0.7,
    "monitor": 0.8,
}
threshold = THRESHOLDS.get(mode, 0.75)
```

---

## Testing

```python
# Tests verify behavior unchanged after refactoring

def test_process_gaps_no_gaps(orchestrator):
    """Test with no gaps."""
    draft = '{"analysis": "test", "information_gaps": []}'
    result = await orchestrator.process_gaps(draft)
    assert result == []


def test_process_gaps_with_gaps(orchestrator):
    """Test with valid gaps."""
    draft = '''{
        "information_gaps": [{
            "importance": "critical",
            "suggested_queries": ["test query"]
        }]
    }'''
    result = await orchestrator.process_gaps(draft)
    # Verify same behavior as before


def test_filter_sources_strict(source_filter):
    """Test strict mode filtering."""
    items = [
        {"tier": 1, "url": "http://a.com"},
        {"tier": 3, "url": "http://b.com"},
    ]
    result = source_filter.filter_sources(items, "strict")
    assert len(result) == 1
    assert result[0]["tier"] == 1
```

---

## Checklist

- [ ] Identify methods with 4+ nesting levels
- [ ] Apply early return pattern
- [ ] Extract nested blocks to helper methods
- [ ] Use dictionary lookups for switch logic
- [ ] Write tests to verify behavior unchanged
- [ ] Review for readability improvement

---

## Benefits

- ✅ Flatter control flow (max 2-3 levels)
- ✅ Each method does one thing
- ✅ Easier to read and understand
- ✅ Natural breakpoints for testing
- ✅ Better error handling
- ✅ Reduced cognitive load
